import react, { ReactElement } from 'react';
import { ExternalProvider, JsonRpcProvider, Web3Provider } from '@ethersproject/providers';
import { AbstractProvider } from 'web3-core';
import EventEmitter from 'eventemitter3';
import { TypedMessage, MessageTypes } from '@metamask/eth-sig-util';
import { FetchOptions } from 'ofetch';

/**
 * We support a subset of the provider methods found here:
 *
 *     https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods
 *
 * For now, we're focused on signing-related methods because the iframe (this code)
 * is the only place that has access to the private key and thus is the only one
 * who can create signatures. All other methods do not need the private key and
 * can therefore be implemented by clients of the iframe.
 */

declare const SUPPORTED_JSON_RPC_METHODS: readonly ["eth_sign", "eth_populateTransactionRequest", "eth_signTransaction", "personal_sign", "eth_signTypedData_v4"];
type JsonRpcMethodType = typeof SUPPORTED_JSON_RPC_METHODS[number];
type Quantity = string | number | bigint;
type UnsignedTransactionRequest = {
    from?: string;
    to?: string;
    nonce?: number;
    gasLimit?: Quantity;
    gasPrice?: Quantity;
    data?: ArrayLike<number> | string;
    value?: Quantity;
    chainId?: number;
    type?: number;
    accessList?: Array<{
        address: string;
        storageKeys: Array<string>;
    }> | Array<[string, Array<string>]> | Record<string, Array<string>>;
    maxPriorityFeePerGas?: Quantity;
    maxFeePerGas?: Quantity;
};
type TransactionLog = {
    blockNumber: number;
    blockHash: string;
    transactionIndex: number;
    removed: boolean;
    address: string;
    data: string;
    topics: Array<string>;
    transactionHash: string;
    logIndex: number;
};
type TransactionReceipt = {
    to: string;
    from: string;
    contractAddress: string;
    transactionIndex: number;
    root?: string;
    logs: Array<TransactionLog>;
    logsBloom: string;
    blockHash: string;
    transactionHash: string;
    blockNumber: number;
    confirmations: number;
    byzantium: boolean;
    type: number;
    status?: number;
    gasUsed: string;
    cumulativeGasUsed: string;
    effectiveGasPrice: string;
};
interface BaseRpcRequestType {
    method: JsonRpcMethodType;
}
interface eth_populateTransactionRequest extends BaseRpcRequestType {
    method: 'eth_populateTransactionRequest';
    params: [UnsignedTransactionRequest];
}
interface eth_populateTransactionRequestResponse {
    method: 'eth_populateTransactionRequest';
    data: UnsignedTransactionRequest;
}
interface eth_signTransaction extends BaseRpcRequestType {
    method: 'eth_signTransaction';
    params: [UnsignedTransactionRequest];
}
interface eth_sign extends BaseRpcRequestType {
    method: 'eth_sign';
    params: [address: string, message: string];
}
interface eth_signResponse {
    method: 'eth_sign';
    data: string;
}
interface personal_sign extends BaseRpcRequestType {
    method: 'personal_sign';
    params: [string, string];
}
interface personal_signResponse {
    method: 'personal_sign';
    data: string;
}
interface eth_signTransactionResponse {
    method: 'eth_signTransaction';
    data: string;
}
interface eth_signTypedData_v4 extends BaseRpcRequestType {
    method: 'eth_signTypedData_v4';
    params: [string, TypedMessage<MessageTypes> | string];
}
interface eth_signTypedData_v4Response {
    method: 'eth_signTypedData_v4';
    data: string;
}
type RpcRequestType = eth_signTransaction | eth_populateTransactionRequest | eth_sign | personal_sign | eth_signTypedData_v4;
type RpcResponseType = eth_signTransactionResponse | eth_populateTransactionRequestResponse | eth_signResponse | personal_signResponse | eth_signTypedData_v4Response;

type WalletCreateRequestDataType = {
    accessToken: string;
    recoveryPin?: string;
};
type WalletConnectRequestDataType = {
    accessToken: string;
    address: string;
};
type WalletRecoverRequestDataType = {
    accessToken: string;
    address: string;
    recoveryPin?: string;
};
type WalletRpcRequestDataType = {
    accessToken: string;
    address: string;
    request: RpcRequestType;
};
type WalletCreateResponseDataType = {
    address: string;
};
type WalletConnectResponseDataType = {
    address: string;
};
type WalletRecoverResponseDataType = {
    address: string;
};
type WalletRpcResponseDataType = {
    address: string;
    response: RpcResponseType;
};
interface EmbeddedWalletProxy {
    create: (data: WalletCreateRequestDataType) => Promise<WalletCreateResponseDataType>;
    connect: (data: WalletConnectRequestDataType) => Promise<WalletConnectResponseDataType>;
    recover: (data: WalletRecoverRequestDataType) => Promise<WalletRecoverResponseDataType>;
    rpc: (data: WalletRpcRequestDataType) => Promise<WalletRpcResponseDataType>;
}

declare abstract class PrivyError extends Error {
    /**
     * Privy error type.
     */
    abstract type: string;
    /**
     * Original Error object, it the error originated client-side.
     */
    cause?: Error;
    /**
     * An optional error code, often included in Privy API responses.
     */
    privyErrorCode?: PrivyErrorCode;
    /**
     * @param type Privy error type.
     * @param message Human-readable message.
     * @param cause Source of this error.
     */
    protected constructor(message: string, cause?: unknown, privyErrorCode?: PrivyErrorCode);
    toString(): string;
}
declare enum PrivyErrorCode {
    MISSING_OR_INVALID_PRIVY_APP_ID = "missing_or_invalid_privy_app_id",
    MISSING_OR_INVALID_PRIVY_ACCOUNT_ID = "missing_or_invalid_privy_account_id",
    INVALID_DATA = "invalid_data",
    LINKED_TO_ANOTHER_USER = "linked_to_another_user",
    ALLOWLIST_REJECTED = "allowlist_rejected",
    CLIENT_REQUEST_TIMEOUT = "client_request_timeout"
}

/**
 * A ProviderRpcError combines the necessary bits of the {PrivyError} with the
 * EIP-compliant ProviderRpcError. This is meant to be a type around errors raised
 * by the ethereum provider.
 */
declare class ProviderRpcError extends PrivyError {
    type: string;
    readonly code: number;
    readonly data?: unknown;
    constructor(message: string, code: number, data?: unknown);
}

declare global {
    interface Window {
        ethereum?: any;
    }
}
type ProviderConnectInfo = {
    chainId: string;
};
type OnConnectEventHandler = (connectInfo: ProviderConnectInfo) => void;
type OnDisconnectEventHandler = (error: ProviderRpcError) => void;
type OnChainChangedEventHandler = (chainId: string | number) => void;
type OnAccountsChangedEventHandler = (accounts: string[]) => void;
type ProviderMessage = {
    type: string;
    data: unknown;
};
type OnMessageEventHandler = (message: ProviderMessage) => void;
type EIP1193OnEventHandler = OnConnectEventHandler | OnDisconnectEventHandler | OnChainChangedEventHandler | OnAccountsChangedEventHandler | OnMessageEventHandler;
interface EIP1193Provider {
    request: (request: {
        method: string;
        params?: Array<any> | undefined;
    }) => Promise<any>;
    on: (eventName: string, listener: EIP1193OnEventHandler) => any;
    removeListener: (eventName: string | symbol, listener: (...args: any[]) => void) => any;
}
/**
 * The PrivyProxyProvider adds a middleware layer on top of the underlying wallet provider.
 * @hidden
 * */
declare class PrivyProxyProvider implements EIP1193Provider {
    walletProvider?: EIP1193Provider;
    private _subscriptions;
    constructor(walletProvider?: EIP1193Provider);
    on(eventName: string, listener: (...args: any[]) => void): any;
    request(request: {
        method: string;
        params?: any[] | undefined;
    }): Promise<any>;
    removeListener: (eventName: string | symbol, listener: (...args: any[]) => void) => any;
    setWalletProvider: (provider: EIP1193Provider) => void;
}
interface RequestArguments {
    readonly method: string;
    readonly params?: readonly unknown[] | object;
}
declare class Embedded1193Provider extends EventEmitter implements EIP1193Provider {
    walletProxy: EmbeddedWalletProxy;
    address: string;
    provider: JsonRpcProvider;
    chainId: number;
    constructor(walletProxy: EmbeddedWalletProxy, address: string, chainId?: number);
    handleSendTransaction(args: RequestArguments): Promise<string>;
    private handleSwitchEthereumChain;
    private handlePersonalSign;
    private handleEstimateGas;
    request(args: RequestArguments): Promise<unknown>;
    connect(): Promise<string | null>;
}
/**
 * Shim to convert to ethers-compatible ExternalProvider class.
 * @hidden
 */
declare class AsExternalProvider extends PrivyProxyProvider implements ExternalProvider {
    constructor(provider: EIP1193Provider);
    isMetaMask?: boolean;
    isStatus?: boolean;
    host?: string;
    path?: string;
    sendAsync?: (request: {
        method: string;
        params?: Array<any>;
    }, callback: (error: any, response: any) => void) => void;
    send?: (request: {
        method: string;
        params?: Array<any>;
    }, callback: (error: any, response: any) => void) => void;
}

interface ConnectorEvents {
    walletsUpdated(): void;
    initialized(): void;
}
/**
 * @hidden
 *
 * A WalletConnector is identified by a connectorType and walletClientType. A
 * connectorType includes injected, wallet_connect, etc. A walletClientType
 * includes metamask, trustwallet, etc.
 *
 * Each WalletConnector manages a list of wallets, identified by an address
 * and chainId. Each wallet has a connected property indicating its current
 * connection status, which is determined based on events emitted by the
 * underlying provider.
 *
 * The WalletConnector also emits two events: walletsUpdated and initialized.
 * The walletsUpdated event is triggered when the list of wallets changes,
 * while the initialized event is triggered when the WalletConnector is
 * ready and has successfully executed the syncAccounts() function for
 * the first time.
 */
declare abstract class WalletConnector extends EventEmitter<ConnectorEvents> {
    connected: boolean;
    initialized: boolean;
    wallets: BaseConnectedWallet[];
    walletClientType: WalletClientType;
    abstract connectorType: ConnectorType;
    abstract proxyProvider: PrivyProxyProvider | Embedded1193Provider;
    constructor(walletClientType: WalletClientType);
    /**
     * Builds a connected wallet object to be exposed to the developer. This object
     * contains the address, chainId, and a few helper methods.
     *
     * Provider methods share the PrivyProxyProvider instance. This means that multiple
     * wallets may share the same provider if one wallet was disconnected and another
     * wallet was connected.
     *
     * A wallet is considered connected if it is present in the wallets array and is
     * in a connected state.
     */
    buildConnectedWallet(address: string, chainId: string): BaseConnectedWallet;
    /**
     * Sync all accounts available via the provider if the wallet is connected.
     *
     * @param prefetchedAccounts - pass in an accounts array from eth_accounts if already fetched to avoid a repeated call
     */
    syncAccounts(prefetchedAccounts?: string[]): Promise<void>;
    /**
     * Get the most recently connected wallet.
     */
    getConnectedWallet(): Promise<BaseConnectedWallet | null>;
    /**
     * As a proxy for "connected", we call eth_accounts and consider the client
     * connected if at least one account is returned.
     */
    isConnected(): Promise<boolean>;
    /**
     * Perform personal_sign with the user's wallet.
     *
     * @param {string} message The message to sign.
     * @returns {string} The resulting signature.
     */
    sign(message: string): Promise<string>;
    protected onAccountsChanged: (accounts: string[]) => void;
    protected onChainChanged: (chainId: string) => void;
    protected onDisconnect: () => void;
    protected onConnect: () => void;
    subscribeListeners(): void;
    unsubscribeListeners(): void;
    abstract get walletBranding(): WalletBranding;
    abstract connect(options: {
        showPrompt?: boolean;
        chainId?: number;
    }): Promise<BaseConnectedWallet | null>;
    abstract disconnect(): void;
    abstract promptConnection(walletClientType: WalletClientType): void;
}

declare const SUPPORTED_OAUTH_PROVIDERS: readonly ["google", "discord", "twitter", "github", "apple"];
type OAuthProviderType = typeof SUPPORTED_OAUTH_PROVIDERS[number];
/** @hidden */
type EmbeddedWalletClientType = 'privy';
/** @hidden */
type InjectedWalletClientType = 'metamask' | 'phantom';
/** @hidden */
type CoinbaseWalletClientType = 'coinbase_wallet';
/** @hidden
 *
 * How this works:
 *
 * The raw data is pulled from https://registry.walletconnect.com/api/v3/wallets
 * Some post-processing is done using the following script.
 *
 * const axios = require('axios');
 * const walletTypes = [];
 * axios.get("https://explorer-api.walletconnect.com/v3/wallets?projectId=2f05ae7f1116030fde2d36508f472bfb&entries=400&page=1&version=2&chains=eip155%3A1").then((apiResult) => {
 *   Object.values(apiResult.data.listings).forEach((walletEntry) => {
 *     if (!walletEntry.mobile.native || !walletEntry.mobile.universal) return;
 *     if (!walletEntry.chains.includes('eip155:1')) return;
 *     if (!walletEntry.metadata.shortName) return;
 *     // Manually removed for cleanliness
 *     if (walletEntry.id === 'b2ce31fb31735fa886270806340de999f72342a7c29484badd8d4d013d77c8b8') return;
 *     if (walletEntry.id) walletTypes.push(`'${walletEntry.id}'`);
 *   });
 *   console.log(walletTypes.join("\n  | "));
 * });
 */
type WalletConnectWalletClientType = 'metamask' | 'trust' | 'safe' | 'rainbow' | 'uniswap' | 'zerion' | 'argent' | 'spot' | 'omni' | 'cryptocom' | 'blockchain' | 'safepal' | 'bitkeep' | 'zengo' | '1inch' | 'binance' | 'exodus' | 'mew_wallet' | 'alphawallet' | 'keyring_pro' | 'mathwallet' | 'unstoppable' | 'obvious' | 'ambire' | 'internet_money_wallet' | 'coin98' | 'abc_wallet' | 'arculus_wallet' | 'haha' | 'cling_wallet' | 'broearn' | 'copiosa' | 'burrito_wallet' | 'enjin_wallet' | 'plasma_wallet' | 'avacus' | 'bee' | 'pitaka' | 'pltwallet' | 'minerva' | 'kryptogo' | 'prema' | 'slingshot' | 'kriptonio' | 'timeless' | 'secux' | 'bitizen' | 'blocto' | 'safemoon';
/** @hidden */
type UnknownWalletClientType = 'unknown';
type WalletClientType = InjectedWalletClientType | CoinbaseWalletClientType | WalletConnectWalletClientType | EmbeddedWalletClientType | UnknownWalletClientType;
declare const SUPPORTED_CONNECTOR_TYPES: string[];
type ConnectorType = typeof SUPPORTED_CONNECTOR_TYPES[number];
/**
 * Wallet metadata currently for internal use only
 */
type WalletBranding = {
    name: string;
    icon?: string | EmbeddedSVG;
};
type LinkedAccountType = 'wallet' | 'email' | 'phone' | 'google_oauth' | 'twitter_oauth' | 'discord_oauth' | 'github_oauth' | 'apple_oauth';
/** @ignore */
interface LinkMetadata {
    /** Account type, most commonly useful when filtering through linkedAccounts */
    type: LinkedAccountType;
    /** Datetime when this account was linked to the user. */
    verifiedAt: Date;
}
/**
 * Object representation of a user's wallet.
 */
interface Wallet {
    /** The wallet address. */
    address: string;
    /**
     * @deprecated Use `chainId` instead.
     *
     * Chain type of the wallet address.
     */
    chainType: 'ethereum' | 'solana';
    /**
     * CAIP-2 formatted chain ID during the most recent verification.
     *
     * e.g. eip155:1, eip155:5, eip155:137, etc.
     */
    chainId?: string;
    /**
     * @deprecated Use `walletClientType` instead.
     */
    walletClient: 'privy' | 'unknown';
    /**
     * The wallet client used for this wallet during the most recent verification.
     *
     * If the value is `privy`, then this is a privy embedded wallet.
     *
     * Other values include but are not limited to `metamask`, `rainbow`, `coinbase_wallet`, etc.
     */
    walletClientType?: string;
    /**
     * The connector type used for this wallet during the most recent verification.
     *
     * This includes but is not limited to `injected`, `wallet_connect`, `coinbase_wallet`, `embedded`.
     */
    connectorType?: string;
    /**
     * If this is a 'privy' embedded wallet, stores the recovery method:
     *
     *     1. 'privy': privy escrow of the recovery material
     *     2. 'user-passcode': recovery protected by user-input passcode
     */
    recoveryMethod?: 'privy' | 'user-passcode';
}
/**
 * Object representation of a base connected wallet from a wallet connector.
 */
interface BaseConnectedWallet {
    /** The wallet address. */
    address: string;
    /** The current chain ID with CAIP-2 formatting. */
    chainId: string;
    /** The first time this wallet was connected without break. */
    connectedAt: number;
    /**
     * @experimental **Experimental**: This property is {@link https://docs.privy.io/guide/guides/experimental-features subject to change at any time}.
     *
     * The wallet client where this key-pair is stored.
     * e.g. metamask, rainbow, coinbase_wallet, etc.
     */
    walletClientType: WalletClientType;
    /**
     * @experimental **Experimental**: This property is {@link https://docs.privy.io/guide/guides/experimental-features subject to change at any time}.
     *
     * The connector used to initiate the connection with the wallet client.
     * e.g. injected, wallet_connect, coinbase_wallet, etc.
     */
    connectorType: ConnectorType;
    /** Returns true if the wallet is connected, false otherwise */
    isConnected: () => Promise<boolean>;
    /** Helper methods to build providers for interfacing with this wallet. */
    getEthereumProvider: () => Promise<EIP1193Provider>;
    getEthersProvider: () => Promise<Web3Provider>;
    getWeb3jsProvider: () => Promise<AbstractProvider>;
    /**
     * Perform personal_sign with the user's wallet.
     *
     * @param {string} message The message to sign.
     * @returns {string} The resulting signature.
     */
    sign: (message: string) => Promise<string>;
    /**
     * @experimental **Experimental**: This property is {@link https://docs.privy.io/guide/guides/experimental-features subject to change at any time}.
     *
     * Disconnect method does not work on all connector types and will no-op if
     * an incompatible connector is used (metamask and phantom do not support
     * programmatic disconnects)
     */
    disconnect: () => void;
}
/**
 * Object representation of a connected wallet.
 */
interface ConnectedWallet extends BaseConnectedWallet {
    /** True if this wallet is linked to the authenticated user. False if it is not yet linked or
     * the user has not yet authenticated. */
    linked: boolean;
    /** Login with this wallet or link this wallet to the authenticated user.
     *
     * Throws a PrivyClientError if the wallet is not connected.
     */
    loginOrLink: () => Promise<void>;
    /** Unlink this wallet to the authenticated user. Throws a PrivyClientError if the user is not
     * authenticated. */
    unlink: () => Promise<void>;
}
/** Object representation of a user's email. */
interface Email {
    /** The email address. */
    address: string;
}
/** Object representation of a user's phone number. */
interface Phone {
    /** The phone number. */
    number: string;
}
/** Object representation of a user's Google account. */
interface Google {
    /** The `sub` claim from the Google-issued JWT for this account. */
    subject: string;
    /** The email associated with the Google account. */
    email: string;
    /** The name associated with the Google account. */
    name: string | null;
}
/** Object representation of a user's Twitter account. */
interface Twitter {
    /** The `sub` claim from the Twitter-issued JWT for this account. */
    subject: string;
    /** The username associated with the Twitter account. */
    username: string | null;
    /** The name associated with the Twitter account. */
    name: string | null;
}
/** Object representation of a user's Discord account. */
interface Discord {
    /** The `sub` claim from the Discord-issued JWT for this account. */
    subject: string;
    /** The username associated with the Discord account.  */
    username: string | null;
    /** The email associated with the Discord account. */
    email: string | null;
}
/** Object representation of a user's Github account. */
interface Github {
    /** The `sub` claim from the Github-issued JWT for this account. */
    subject: string;
    /** The username associated with the Github account.  */
    username: string | null;
    /** The name associated with the Github account. */
    name: string | null;
    /** The email associated with the Github account. */
    email: string | null;
}
/** Object representation of a user's Apple account. */
interface Apple {
    /** The `sub` claim from the Apple-issued JWT for this account. */
    subject: string;
    /** The email associated with the Apple account. */
    email: string;
}
/** Object representation of a user's email, with additional metadata for advanced use cases. */
interface EmailWithMetadata extends LinkMetadata, Email {
    /** Denotes that this is an email account. */
    type: 'email';
}
/** Object representation of a user's phone number, with additional metadata for advanced use cases. */
interface PhoneWithMetadata extends LinkMetadata, Phone {
    /** Denotes that this is a phone account. */
    type: 'phone';
}
/** Object representation of a user's wallet, with additional metadata for advanced use cases. */
interface WalletWithMetadata extends LinkMetadata, Wallet {
    /** Denotes that this is a wallet account. */
    type: 'wallet';
}
/** Object representation of a user's Google Account, with additional metadata for advanced use cases. */
interface GoogleOAuthWithMetadata extends LinkMetadata, Google {
    /** Denotes that this is a Google account. */
    type: 'google_oauth';
}
/** Object representation of a user's Twitter Account, with additional metadata for advanced use cases. */
interface TwitterOAuthWithMetadata extends LinkMetadata, Twitter {
    /** Denotes that this is a Twitter account. */
    type: 'twitter_oauth';
}
/** Object representation of a user's Discord Account, with additional metadata for advanced use cases. */
interface DiscordOAuthWithMetadata extends LinkMetadata, Discord {
    /** Denotes that this is a Discord account. */
    type: 'discord_oauth';
}
/** Object representation of a user's Github Account, with additional metadata for advanced use cases. */
interface GithubOAuthWithMetadata extends LinkMetadata, Github {
    /** Denotes that this is a Github account. */
    type: 'github_oauth';
}
/** Object representation of a user's Apple Account, with additional metadata for advanced use cases. */
interface AppleOAuthWithMetadata extends LinkMetadata, Apple {
    /** Denotes that this is a Apple account. */
    type: 'apple_oauth';
}
/**
 * Object representation of a user's linked accounts
 */
type LinkedAccountWithMetadata = WalletWithMetadata | EmailWithMetadata | PhoneWithMetadata | GoogleOAuthWithMetadata | TwitterOAuthWithMetadata | DiscordOAuthWithMetadata | GithubOAuthWithMetadata | AppleOAuthWithMetadata;
interface User {
    /** The Privy-issued DID for the user. If you need to store additional information
     * about a user, you can use this DID to reference them. */
    id: string;
    /** The datetime of when the user was created. */
    createdAt: Date;
    /** The user's email address, if they have linked one. It cannot be linked to another user. */
    email?: Email;
    /** The user's phone number, if they have linked one. It cannot be linked to another user. */
    phone?: Phone;
    /** The user's most recently linked wallet, if they have linked at least one wallet.
     *  It cannot be linked to another user.
     *  This wallet is the wallet that will be used for transactions and signing if it is connected.
     **/
    wallet?: Wallet;
    /** The user's Google account, if they have linked one. It cannot be linked to another user. */
    google?: Google;
    /** The user's Twitter account, if they have linked one. It cannot be linked to another user. */
    twitter?: Twitter;
    /** The user's Discord account, if they have linked one. It cannot be linked to another user. */
    discord?: Discord;
    /** The user's Github account, if they have linked one. It cannot be linked to another user. */
    github?: Github;
    /** The user's Apple account, if they have linked one. It cannot be linked to another user. */
    apple?: Apple;
    /** The list of accounts associated with this user. Each account contains additional metadata
     * that may be helpful for advanced use cases. */
    linkedAccounts: Array<LinkedAccountWithMetadata>;
}
type PrivyServerConfig = {
    id?: string;
    name?: string;
    verificationKey?: string;
    showWalletLoginFirst?: boolean;
    allowlistConfig: AllowlistConfig;
    walletAuth?: boolean;
    emailAuth?: boolean;
    smsAuth?: boolean;
    googleOAuth?: boolean;
    twitterOAuth?: boolean;
    discordOAuth?: boolean;
    githubOAuth?: boolean;
    appleOAuth?: boolean;
    termsAndConditionsUrl: string | null;
    privacyPolicyUrl: string | null;
    createdAt?: Date;
    updatedAt?: Date;
    customApiUrl?: string | null;
    walletConnectCloudProjectId?: string | null;
    embeddedWalletConfig: EmbeddedWalletsConfig;
    /** May be deprecated from the server config in a future release */
    logoUrl?: string;
    /** May be deprecated from the server config in a future release */
    accentColor?: string;
};
type HexColor = `#${string}`;
type PrivyClientConfig = {
    /** All UI and theme related configuration */
    appearance?: {
        /** Primary theme for the privy UI. This dictates the foreground and background colors within the UI.
         *
         *  'light' (default): The privy default light UI.
         *  'dark': The privy default dark UI.
         *  custom hex code (i.e. '#13152F'): A custom background. This will generate the remainder of the foreground and
         *  background colors for the UI by modulating the luminance of the passed color. This value should be _either_ dark
         *  or light (<20% or >80% luminance), for accessibility. */
        theme?: 'light' | 'dark' | HexColor;
        /** Accent color for the privy UI.
         *  Used for buttons, active borders, etc. This will generate light and dark variants.
         *  This overrides the server setting `accent_color`. */
        accentColor?: HexColor;
        /** Logo for the main privy modal screen.
         *  This can be a string (url) or an img / svg react element.
         *  If passing an element, Privy will overwrite the `style` props, to ensure proper rendering.
         *  This overrides the server setting `logo_url` */
        logo?: string | ReactElement;
        /** Determines the order of the login options in the privy modal. If true, the wallet login will render above
         *  social and email / sms login options.
         *  This overrides the server setting `show_wallet_login_first` */
        showWalletLoginFirst?: boolean;
    };
    /** Specified login methods for the privy modal.
     *  If this parameter is included, it will override any login method settings specified on the server.
     *  Only `email` OR `sms` can be specified, not both. If both are specified, `email` will be used.
     *  Social login methods require `email` OR `sms` to also be specified.
     *  `loginMethods` cannot be an empty array if specified.
     *  The order of this array does not currently dictate order of the login methods in the UI, but may in the future. */
    loginMethods?: Array<'wallet' | 'email' | 'sms' | 'google' | 'twitter' | 'discord' | 'github' | 'apple'>;
    /** All legal configuration */
    legal?: {
        /** URL to the terms and conditions page for your application.
         *  Rendered as a link in the privy modal footer.
         *  This overrides the server setting `terms_and_conditions_url` */
        termsAndConditionsUrl?: string | null;
        /** URL to the privacy policy page for your application.
         *  Rendered as a link in the privy modal footer.
         *  This overrides the server setting `privacy_policy_url` */
        privacyPolicyUrl?: string | null;
    };
    walletConnectCloudProjectId?: string;
    /** All embedded wallets configuration */
    embeddedWallets?: {
        /**
         * Whether an embedded wallet should be created for the user on login. This overrides the
         * deprecated `createPrivyWalletOnLogin`.
         *
         * For `all-users`, the user will be prompted to create a Privy wallet after successfully
         * logging in. If they cancel or are visiting after this flag was put in place, they will be
         * prompted to create a wallet on their next login.
         *
         * For `users-without-wallets`, the user will be prompted to create a Privy wallet after\
         * successfully logging in, only if they do not currently have any wallet associated with their
         * user object - for example if they have linked an external wallet.
         *
         * For `off`, an embedded wallet is not created during login. You can always prompt the user to
         * create one manually with your app.
         *
         * Defaults to 'off'.
         */
        createOnLogin?: EmbeddedWalletCreateOnLoginConfig;
        /**
         * If true, Privy will prompt users to create a password for their Privy embedded wallet.
         * If false, embedded wallets will be created without the need of password.
         *
         * Defaults to false.
         */
        requireUserPasswordOnCreate?: boolean;
        /**
         * If true, Privy will not prompt or instantiate any UI for embedded wallet signatures and transactions.
         * If false, embedded wallet actions will raise a modal and require user confirmation to proceed.
         *
         * Defaults to false.
         */
        noPromptOnSignature?: boolean;
    };
    /**
     * Override the default rendering settings, used for displaying in a non-modal setting.
     * For internal use only.
     * @hidden
     */
    _render?: {
        /**
         * If true, the modal renders with a dialog, which centers the modal, blocks scrolling on the body, adds a backdrop,
         * and adds a close button in the top right corner.
         * If false, the modal renders wherever the portal is set to (defaults to the bottom of document.body), without the above features.
         *
         * Defaults to true.
         */
        inDialog?: boolean;
        /**
         * The id of the node to render the modal in, using a React portal.
         * If the element with id specified does not exist, or is set to null, renders to document.body.
         *
         * Defaults to null.
         */
        inParentNodeId?: string | null;
    };
};
interface AllowlistConfig {
    errorTitle: string | null;
    errorDetail: string | null;
    errorCtaText: string | null;
    errorCtaLink: string | null;
}
type EmbeddedWalletCreateOnLoginConfig = 'users-without-wallets' | 'all-users' | 'off';
interface EmbeddedWalletsConfig {
    createOnLogin: EmbeddedWalletCreateOnLoginConfig;
    requireUserPasswordOnCreate: boolean;
}
type SignMessageModalUIOptions = {
    title?: string;
    description?: string;
    buttonText?: string;
};
type SendTransactionModalTransactionInfo = {
    description?: string;
    action: string;
    actionDescription: string;
};
type SenderInfo = {
    url: string;
    name: string;
    actionText: string;
    imgUrl?: string;
    imgAltText?: string;
    imgSize?: 'sm' | 'lg';
};
type SendTransactionModalUIOptions = {
    modalTitle?: string;
    title?: string;
    description?: string;
    buttonText?: string;
    senderInfo?: SenderInfo;
    transactionInfo?: SendTransactionModalTransactionInfo;
};

declare function getAccessToken(): Promise<string | null>;
/**
 * Properties to initialize the {@link PrivyProvider}.
 */
interface PrivyProviderProps {
    /** Your Privy App ID, which can be retrieved from the Privy console. */
    appId: string;
    /**
     * An optional callback that will execute once a `login` call successfully completes.
     *
     * Within this callback, you can access:
     * - the `user` object corresponding to the authenticated user
     * - an `isNewUser` boolean flag indicating if this is the user's first time logging in to your app
     *
     */
    onSuccess?: (user: User, isNewUser: boolean) => void;
    /**
     * @deprecated use `config.embeddedWallets.createOnLogin` instead
     */
    createPrivyWalletOnLogin?: boolean;
    /**
     * Client configuration options.
     * Values here will override their server-configuration counterparts.
     */
    config?: PrivyClientConfig;
    /**
     * Override the URL of the Privy API, which is 'https://auth.privy.io' by default.
     * For development and testing use only.
     * @hidden
     */
    apiUrl?: string;
    /**
     * @ignore
     * @class
     */
    children: react.ReactNode;
}
/**
 * Passes the Privy authentication context to your React components.
 *
 * This should wrap any components that will to use the Privy SDK via the {@link usePrivy} hook. As an example:
 *
 * ```typescript
 * // At your application root (e.g. `_app.tsx` in NextJS):
 * import {PrivyProvider} from '@privy-io/react-auth';
 *
 * <PrivyProvider appId="APP_ID_FROM_CONSOLE" onSuccess={() => console.log('Success!')}>
 *   <Component {...pageProps} />
 * </PrivyProvider>
 * ```
 *
 */
declare const PrivyProvider: ({ config, ...props }: PrivyProviderProps) => JSX.Element;

interface ConnectorManagerEvents {
    walletsUpdated(): void;
}
/** @hidden */
declare class ConnectorManager extends EventEmitter<ConnectorManagerEvents> {
    walletConnectors: WalletConnector[];
    initialized: boolean;
    private storedConnections;
    private activeWallet?;
    private walletConnectCloudProjectId;
    constructor(walletConnectCloudProjectId: string);
    /**
     * The core wallets array that is exposed to developers. It builds
     * the wallets away with the following logic:
     *
     * 1. Flatten all wallets from all connectors
     * 2. Sorted by connectedAt
     * 3. Active wallet is moved to front of array (if it exists)
     */
    get wallets(): BaseConnectedWallet[];
    /**
     * Detect and add all valid wallet connectors.
     */
    initialize(): void;
    /**
     * Helper function to find a wallet connector by connector type and wallet client type.
     */
    findWalletConnector(connectorType: ConnectorType, walletClientType: WalletClientType): WalletConnector | null;
    /**
     * Add any connectedAt overrides for newly initialized wallets and pass-through change events.
     */
    private onInitialized;
    /**
     * Save connection history and pass-through change events.
     */
    private onWalletsUpdated;
    addEmbeddedWalletConnector(walletProxy: EmbeddedWalletProxy, address: string): void;
    /**
     * Normally, we do not remove connectors after creation. Privy embedded wallets are an exception
     * because they are closely tied with an authenticated state.
     */
    removeEmbeddedWalletConnector(): void;
    /**
     * Creates a new wallet connector for the given connector type and wallet client type.
     * If a connector already exists, it will be returned instead.
     */
    createWalletConnector(connectorType: ConnectorType, walletClientType: WalletClientType): Promise<WalletConnector | null>;
    private addWalletConnector;
    /**
     * Upon initialization, loads previous connections from local storage. If local storage
     * is misformatted (e.g. due to previous privy:connectors usage), it returns an empty array that
     * will be overwritten later.
     *
     * @returns StoredConnection[] list of stored connections from previous session
     */
    private loadConnectionHistory;
    /**
     * Saves all current connections to local storage overridding any previous connections.
     */
    private saveConnectionHistory;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with wallets directly (wallets[0].getEthereumProvider()).
     *
     * Build an Ethereum provider for the most recently connected wallet.
     */
    getEthereumProvider: () => EIP1193Provider;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with `wallets` directly.
     *
     * Performing personal_sign with the most recently connected wallet.
     * If there is not a wallet connected, return null.
     */
    activeWalletSign(message: string): Promise<string | null>;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with `wallets` directly.
     */
    setActiveWallet(address: string): void;
}

/**
 * Allows you to manage the user's current authentication state and access their linked accounts.
 * You can access the fields and methods documented here via the {@link usePrivy} hook.
 */
interface PrivyInterface {
    /**
     * Check whether the `PrivyProvider` is ready to be used. You should wait for this to
     * be true before using values such as `authenticated` and `user`.
     */
    ready: boolean;
    /**
     * True if the user is authenticated, false otherwise.
     *
     * You should always check that `ready` is true before using this value. Otherwise,
     * the value may outdated while the Privy client fetches fresh tokens.
     *
     */
    authenticated: boolean;
    /**
     * The user object, or null if the user is not authenticated.
     */
    user: User | null;
    /**
     * Opens the Privy modal and prompts the user to connect a wallet.
     */
    connectWallet: () => void;
    /**
     * Opens the Privy login modal and prompts the user to login.
     */
    login: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link an email.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkEmail: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link a phone number.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkPhone: () => void;
    /**
     * For users who are authenticated, opens the Privy modal and prompts the user to link a wallet.
     * This will open the Privy Modal which will guide the user through this action.
     */
    linkWallet: () => void;
    /**
     * For users who are authenticated, prompts the user to link a Google OAuth account.
     * This will directly initiate the OAuth flow for Google.
     */
    linkGoogle: () => void;
    /**
     * For users who are authenticated, prompts the user to link a Twitter OAuth account
     * This will directly initiate the OAuth flow for Twitter.
     */
    linkTwitter: () => void;
    /**
     * For users who are authenticated, prompts the user to link Discord OAuth account
     * This will directly initiate the OAuth flow for Discord.
     */
    linkDiscord: () => void;
    /**
     * For users who are authenticated, prompts the user to link Github OAuth account
     * This will directly initiate the OAuth flow for Github.
     */
    linkGithub: () => void;
    /**
     * For users who are authenticated, prompts the user to link Apple OAuth account
     * This will directly initiate the OAuth flow for Apple.
     */
    linkApple: () => void;
    /**
     * Log the current user out and clears their authentication state. `authenticated` will become false, `user` will become null, and the Privy Auth tokens will be deleted from the browser's local storage.
     *
     * You may await this call to take an action once logout is complete (e.g. redirecting to a specific page).
     */
    logout: () => Promise<void>;
    /**
     * Get the Privy access token ([JWT](https://jwt.io/)) for an authenticated user. Returns null for an unauthenticated user.
     *
     * You may use this token to authorize requests sent from your frontend, and can validate it in your backend against your app's Privy verification key.
     *
     * This will automatically attempt to refresh the session if the token is expired or about to expire.
     */
    getAccessToken: () => Promise<string | null>;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with wallets directly (wallets[0].getEthereumProvider()).
     *
     * Get an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193)-compatible provider from the user's wallet, if the user has connected one.
     *
     * You may then use the Ethereum Javascript API syntax to send JSON-RPC requests to the user's wallet.
     */
    getEthereumProvider: () => EIP1193Provider;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with wallets directly (wallets[0].getEthersProvider()).
     *
     * Get an [ethers.js](https://docs.ethers.io/v5/)-compatible provider from the user's wallet, if the user has connected one.
     *
     */
    getEthersProvider: () => Web3Provider;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by
     * interfacing with wallets directly (wallets[0].getWeb3jsProvider()).
     *
     * Get a [web3.js](https://web3js.readthedocs.io/en/v1.8.0/)-compatible provider from the user's wallet, if the user has connected one.
     */
    getWeb3jsProvider: () => AbstractProvider;
    /**
     * @deprecated **Deprecated**: This feature will be removed and should be replaced by the
     * `useWallet` hook.
     *
     * Get the ConnectorManager object
     * This shouldn't need to be used directly unless creating a plugin, like a WAGMI plugin
     */
    walletConnectors: ConnectorManager | null;
    /**
     * Unlink an email account from a user, by passing the email address. Note that you can only unlink an email account if the user has at least one other account.
     */
    unlinkEmail: (address: string) => Promise<User>;
    /**
     * Unlink a phone account from a user, by passing the phone number. Note that you can only unlink a phone account if the user has at least one other account.
     */
    unlinkPhone: (phoneNumber: string) => Promise<User>;
    /**
     * Unlink a wallet account from a user, by passing the public address. Note that you can only unlink a wallet account if the user has at least one other account.
     * If the unlinked wallet was the active one, and more wallets are linked to the user, then we attempt to make the most recently linked wallet active.
     */
    unlinkWallet: (address: string) => Promise<User>;
    /**
     * Unlink a Google social account from a user, by passing the google subject ID. Note that you can only unlink a social account if the user has at least one other account.
     */
    unlinkGoogle: (subject: string) => Promise<User>;
    /**
     * Unlink a Twitter social account from a user, by passing the twitter subject ID. Note that you can only unlink a social account if the user has at least one other account.
     */
    unlinkTwitter: (subject: string) => Promise<User>;
    /**
     * Unlink a Discord social account from a user, by passing the discord subject ID. Note that you can only unlink a social account if the user has at least one other account.
     */
    unlinkDiscord: (subject: string) => Promise<User>;
    /**
     * Unlink a Github social account from a user, by passing the github subject ID. Note that you can only unlink a social account if the user has at least one other account.
     */
    unlinkGithub: (subject: string) => Promise<User>;
    /**
     * Unlink a Apple social account from a user, by passing the apple subject ID. Note that you can only unlink a social account if the user has at least one other account.
     */
    unlinkApple: (subject: string) => Promise<User>;
    /**
     * @deprecated **Deprecated**: This feature will be removed and behaves the same as connectWallet(). Instead, please
     * interact with the wallets array directly.
     *
     * Note that when you connect a new wallet, it becomes first in the wallets array.
     */
    setActiveWallet: (address: string) => Promise<void>;
    /**
     * @experimental **Experimental**: This feature is {@link https://docs.privy.io/guide/guides/experimental-features subject to change at any time}.
     *
     * Get a short-lived, one-time-use token to start a new Privy session from the existing authenticated session. Raises an exception if the current session was already forked from a previous session.
     */
    forkSession: () => Promise<string>;
    /**
     * @experimental **Experimental**: This feature is {@link https://docs.privy.io/guide/guides/experimental-features subject to change at any time}.
     *
     * Prompts a user to create an Ethereum wallet through Privy.
     *
     * This function will fail if the user has already created a wallet through Privy,
     * as Privy currently only supports creating one wallet per user.
     *
     * This requires a user to enter a recovery pin that can later be used to recover the
     * wallet or port it across devices.
     */
    createWallet: () => Promise<Wallet>;
    /**
     * @experimental **Experimental**: This feature is {@link https://docs.privy.io/guide/guides/experimental-features subject to change at any time}.
     *
     * Prompts a user to sign a message using their Privy wallet.
     *
     * The resulting signature is an EIP-191 personal_sign signature (0x45).
     *
     * This function currently has a precondition that the user has a Privy wallet. It will fail otherwise.
     */
    signMessage: (message: string, uiOptions?: SignMessageModalUIOptions) => Promise<string>;
    sendTransaction: (data: UnsignedTransactionRequest, uiOptions?: SendTransactionModalUIOptions) => Promise<TransactionReceipt>;
    exportWallet: () => Promise<void>;
}
/**
 * [React Hook](https://reactjs.org/docs/hooks-intro.html) that allows you to manage the user's current authentication state and access their linked accounts.
 *
 * You should use this hook to access the Privy SDK from within your React components and custom hooks.
 */
declare const usePrivy: () => PrivyInterface;

/**
 * Allows you to manage the user's currently connected wallets.
 * You can access the fields and methods documented here via the {@link useWallets} hook.
 */
interface UseWalletsInterface {
    /**
     * The user's connected wallets.
     */
    wallets: ConnectedWallet[];
}
declare function useWallets(): UseWalletsInterface;

declare const VERSION: string;

interface ResponseEmailAccount {
    type: 'email';
    address: string;
    verified_at: number;
}
interface ResponsePhoneAccount {
    type: 'phone';
    phoneNumber: string;
    verified_at: number;
}
interface ResponseEthereumAccount {
    type: 'wallet';
    address: string;
    /**
     * @deprecated This will be removed in favor of the CAIP-2 formatted chain_id field.
     *
     * Chain type of the wallet address.
     */
    chain_type: 'ethereum';
    chain_id?: string;
    /**
     * @deprecated Use `wallet_client_type` instead.
     */
    wallet_client: 'privy' | 'unknown';
    wallet_client_type?: string;
    connector_type?: string;
    recovery_method?: 'privy' | 'user-passcode';
    verified_at: number;
}
interface ResponseOAuthGoogle {
    type: 'google_oauth';
    subject: string;
    email: string;
    name: string | null;
    verified_at: number;
}
interface ResponseOAuthTwitter {
    type: 'twitter_oauth';
    subject: string;
    username: string | null;
    name: string | null;
    verified_at: number;
}
interface ResponseOAuthDiscord {
    type: 'discord_oauth';
    subject: string;
    username: string | null;
    email: string | null;
    verified_at: number;
}
interface ResponseOAuthGithub {
    type: 'github_oauth';
    subject: string;
    username: string | null;
    name: string | null;
    email: string | null;
    verified_at: number;
}
interface ResponseOAuthApple {
    type: 'apple_oauth';
    subject: string;
    email: string;
    verified_at: number;
}
type LinkedAccountsResponseType = Array<ResponseEmailAccount | ResponsePhoneAccount | ResponseEthereumAccount | ResponseOAuthGoogle | ResponseOAuthTwitter | ResponseOAuthDiscord | ResponseOAuthGithub | ResponseOAuthApple>;
interface GetCurrentUserResponse {
    id: string;
    created_at: number;
    linked_accounts: LinkedAccountsResponseType;
}

interface DefaultsType {
    baseURL: string;
    timeout: number;
}
/**
 * A raw http handler for making requests to the Privy API. It requires a Session
 * object, which is used for fetching and including any tokens that are required
 * for requests.
 *
 * Should not be used for external requests, as we attach a good deal of metadata to requests.
 */
declare class Http {
    fallbackApiUrl: string;
    private appId;
    private client;
    private defaults;
    private sdkVersion;
    private baseFetch;
    constructor(appId: string, client: PrivyClient, defaults: DefaultsType);
    get<T = any>(path: string, config?: FetchOptions<'json'>): Promise<T>;
    post<T = any, D = any>(path: string, data?: D, config?: FetchOptions<'json'>): Promise<T>;
    delete<T = any>(path: string, config?: FetchOptions<'json'>): Promise<T>;
}

/**
 * Valid /session and <>/authenticate calls will respond with a token
 * as well as a valid user object for streamlining.
 */
interface ValidSessionResponse {
    user: GetCurrentUserResponse;
    token: string;
    refresh_token: string | null;
    is_new_user?: boolean;
}

type AuthMeta = {
    [key: string]: any;
};
/**
 * An auth flow is an encapsulation of the business logic required for a given
 * authentication process. It requires at least one definitive `authenticate`
 * method that does the final token handshaking with the API, but may also
 * include any number of methods/API calls necessary to set up the state (e.g.
 * sending an email before being able to do a passwordless code login)
 */
interface AuthFlow {
    api?: Http;
    /**
     * Any meta information necessary for the auth flow, that may also need to be
     * shared out to things like frontend components for displaying state of the
     * auth flow
     */
    meta: AuthMeta;
    /**
     * Handles the API authentication call(s) to log users in.
     * Any preconditions must be addressed prior to calling
     */
    authenticate(): Promise<ValidSessionResponse>;
    /**
     * Handles the API link call(s) to link new user accounts.
     * Requires user to already be logged in when called.
     * Any preconditions must be addressed prior to calling
     */
    link(): Promise<GetCurrentUserResponse>;
}

/**
 * This should not be directly used by developers at the moment,
 * so we doc-ignore it.
 * @ignore
 *
 */
declare class PrivyClient {
    private api;
    private appId;
    private session;
    private timeout;
    private clientAnalyticsId;
    useServerCookies: boolean;
    apiUrl: string;
    fallbackApiUrl: string;
    authFlow?: AuthFlow;
    connectors?: ConnectorManager;
    /**
     * Creates a new Privy client.
     * @param options Initialization options.
     */
    constructor(options: {
        /**
         * The URL of the Privy API. Defaults to `https://api.privy.io/v0`.
         */
        apiUrl?: string;
        /**
         * The app id from your console
         */
        appId: string;
        /**
         * Time in milliseconds after which to timeout requests to the API. Defaults to `10000` (10 seconds).
         */
        timeout?: number;
    });
    /**
     * ConnectorManager initialization is deferred because the input parameter may be overridden by the server
     * config. We can set this once and only once. If it is set twice, event listeners will be created
     * on the first ConnectorManager and are not re-created.
     */
    initializeConnectorManager(walletConnectCloudProjectId: string): void;
    generateApi(): Http;
    /**
     * In the case of cookie-based auth, re-initialize the http client with the custom api url.
     * @param customApiUrl the custom api url to use for cookie-based authFlow
     */
    updateApiUrl(customApiUrl?: string | null): void;
    authenticate(): Promise<{
        user: User | null;
        isNewUser?: boolean | undefined;
    }>;
    link(): Promise<User | null>;
    logout(): Promise<void>;
    startAuthFlow(authFlow: AuthFlow): void;
    unlinkEmail(address: string): Promise<User>;
    unlinkPhone(phoneNumber: string): Promise<User>;
    unlinkWallet(address: string): Promise<User>;
    unlinkOAuth(provider: OAuthProviderType, subject: string): Promise<User>;
    createAnalyticsEvent(eventName: string, payload?: {
        [key: string]: any;
    }, timestamp?: Date): Promise<void>;
    /** DATA METHODS */
    /**
     * Fetches the currently authenticed user from the API or
     * returns null if the user is not authenticated.
     *
     * This will refresh the user's access token and rotate
     * the refresh token if needed.
     *
     * @returns Promise<User | null>
     */
    getAuthenticatedUser(): Promise<User | null>;
    /**
     * Grab the Privy access token for the currently logged in user. Verifies that the
     * token has a valid signature, was issued by 'privy.io', and corresponds to the
     * current app ID. If no valid token is found, this method will force a logout and return null.
     *
     * If the token is expired or expiring soon, this will attempt to
     * first refresh the access token to ensure that the token is active. You can
     * disable this behavior using `disableAutoRefresh`, although it is not
     * recommended.
     *
     * @param disableAutoRefresh not recommended - optionally disable automatic
     * token refresh when the token is
     *
     * @returns Promise<string | null>
     */
    getAccessToken(options?: {
        disableAutoRefresh?: boolean;
    }): Promise<string | null>;
    getServerConfig(): Promise<PrivyServerConfig>;
    getUsdTokenPrice(chainId: string | number): Promise<number | undefined>;
    /**
     * Get a short-lived token to start a new Privy session from the existing authenticated session.
     *
     * Rotates the access token and refresh token.
     * Raises an exception if the current session was already forked from a previous session,
     * or if the current session is not authenticated.
     *
     * @returns Promise<string>
     */
    forkSession(): Promise<string>;
}

export { Apple, AppleOAuthWithMetadata, AsExternalProvider, ConnectedWallet, ConnectorManager, Discord, DiscordOAuthWithMetadata, EIP1193Provider, Email, EmailWithMetadata, Github, GithubOAuthWithMetadata, Google, GoogleOAuthWithMetadata, Phone, PhoneWithMetadata, PrivyClient, PrivyClientConfig, PrivyInterface, PrivyProvider, PrivyProviderProps, PrivyProxyProvider, Quantity, SendTransactionModalUIOptions, SignMessageModalUIOptions, TransactionLog, TransactionReceipt, Twitter, TwitterOAuthWithMetadata, UnsignedTransactionRequest, UseWalletsInterface, User, VERSION, Wallet, WalletConnector, WalletWithMetadata, getAccessToken, usePrivy, useWallets };
